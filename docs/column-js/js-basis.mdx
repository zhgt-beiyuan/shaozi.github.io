---
title: JS 基础巩固 📦
id: js-basis
sidebar_position: 1
toc_max_heading_level: 4
---

> 本章节简单记录 JavaScript 的一些基础知识 & 面试常见的问题，如 原型、闭包 等;

## 数据类型

### 获取元素的类型

获取目标对象的类型，返回一个字符串;

```jsx title="代码实现" showLineNumbers
export const _getType = (target: any) => {
  return Object.prototype.toString.call(target);
};

// 调用
_getType(undefined); // '[object Undefined]'
_getType(null); // '[object Null]'
_getType({ name: 'dino' }); // '[object Object]'
_getType([1, 2]); // '[object Array]'
_getType(/\d/g); // '[object RegExp]'
_getType(Symbol('dino')); // '[object Symbol]'；es6 新增的原始数据类型，Symbol() 中返回的值都是唯一的

_getType(Array); // '[object Function]'，构造函数
_getType(new Array()); // '[object Array]'，实例化对象
```

### 原始数据类型 的转换

最基本的原始数据类型 `string`、`number` 和 `boolean` 之间的转换;

#### → String

```js title="代码实现" showLineNumbers
// 1️⃣ 使用 toString() 方法
false.toString(); // 'false'
[52].toString(); // '52'

// 2️⃣ 使用 JSON.stringify() 方法
JSON.stringify(123); // '123'

// 3️⃣ 使用 String() 方法
String([]); // ""
String(['52']); // "52"
String({}); // "[object Object]"
String(null); // "null"
String(undefined); // "undefined"
String(true); // "true"

// 4️⃣ 使用 隐式转换，同 String() 一致
'' + 123; // '123'
```

:::caution `toString()` 的参数

- `toString()` 对 **数值(number 类型)** 来说，是转换成对应的 **进制字符串**，该方法可传一个参数，表示对应的 **进制**，默认为 **十进制**;

```js showLineNumbers
(520).toString(); // '520'，十进制（默认）
(520).toString(2); // '1000001000'，二进制
(520).toString(8); // '1010'，八进制
(520).toString(16); // '208'，十六进制
(520).toString(32); // 'g8'，三十二进制
```

:::

#### → Number

```js title="代码实现" showLineNumbers
// 1️⃣ 使用 parseInt() 方法，它会将 浮点数 转换成 整数
parseInt('3.1415'); // 3
parseInt('100++'); // 100
parseInt('++100'); // NaN
parseInt(true); // NaN

// 2️⃣ 使用 parseFloat() 方法，同 parseInt() 一致，但是它不会将 浮点数 转换成 整数
parseFloat('3.14'); // 3.14

// 3️⃣ 使用 Number() 方法
Number(); // 0
Number(null); // 0
Number(false); // 0
Number(''); // 0
Number(' '); // 0，加了空格的字符串

Number(true); // 1
Number([]); // 0
Number(['']); // 0
Number(['5']); // 5

Number(['5', '2']); // NaN
Number({}); // NaN
Number(undefined); // NaN

Number(' 3.14 '); // 3.14
Number(' 3.14 222'); // NaN

// 4️⃣ 使用 隐式转换，同 Number() 一致
+'3.14'; // 3.14
```

:::caution `Number()` 在对目标值转换的过程中，会发生什么?

- 目标对象 先调用自身的 `valueOf()` 方法(返回目标对象的原始值)，若返回的是 **原始类型**，则直接使用 `Number()` 方法; 若返回的是 **引用类型**，会再调用 `toString()` 方法;
- 若调用 `toString()` 方法后，返回的还是一个对象，则会抛出错误;

```js showLineNumbers
Number(['5']); // 相当于 Number(['5'].valueOf().toString())
```

:::

:::caution `parseInt()` 的参数

- `parseInt()` 可传第二个参数，表示对应的 **进制数**，默认为 **十进制**; 但它和 `toString()` 的计算方式刚好相反;

```js showLineNumbers
parseInt('1000001000'); // 1000001000
parseInt('1000001000', 2); // 520
parseInt('1010', 8); // 520
parseInt('208', 16); // 520
parseInt('g8', 32); // 520
```

:::

#### → Boolean

```js title="代码实现" showLineNumbers
// 1️⃣ 使用 Boolean() 方法
Boolean([]); // true
Boolean(0); // false
Boolean(NaN); // false

// 2️⃣ 使用 隐式转换，同 Boolean() 一致(! 表示非；!! 表示转换)
!!{}; // true
!!''; // false
!!null; // false
```

<!-- ## 拓展链接 📦 -->

:::tip 拓展资料

- 👉 [你真的掌握变量和类型了吗? - 掘金](https://juejin.cn/post/6844903854882947080)
- 👉 [在线进制转换工具](https://tool.lu/hexconvert/)

:::

### 判断 对象 是否为空

```jsx title="代码实现" showLineNumbers
// 1️⃣ 将对象转成字符串
JSON.stringify({}); // '{}';

// 2️⃣ 将对象的 key 值组成一个数组
Object.keys({}).length; // 0
// 或
Object.getOwnPropertyNames({}).length; // 0

// 3️⃣ 使用第三方库 lodash 中的 isEmpty() 方法
import { isEmpty } from 'lodash';

isEmpty({}); // true
```

:::caution 离离原上谱

- **lodash** 中的 `isEmpty()` 方法主要用来判断目标值是否为空，为空则返回 `true`，包括 `null`、`undefined` 及 `空数组` 等;
- 📢 当 `isEmpty()` 中的目标值为 `1` 时，也会返回 `true`（该情况比较特殊）;

```js showLineNumbers
isEmpty(null); // true
isEmpty(0); // true
isEmpty(1); // true
isEmpty(true); // true
isEmpty(false); // true
isEmpty([]); // true
isEmpty(''); // true
isEmpty(' '); // false，加了空格的字符串
```

:::

## 运算符

### 神奇的 == 运算符

- 使用 `==` 做比较时，只会比较值，不会比较类型，因此 **不建议在实际开发中使用**;
- `==` 运算符 本质上是将两侧的内容转换成 `Number` 类型，再进行比较;
- `Boolean` 类型的值在和其他类型进行 **比较** 时，该值优先被转换成 `Number` 类型;

```js showLineNumbers
true == 1; // true
true == '1'; // true
true == ['1']; // true，因为 引用类型 ['1'] 会被转换成 Number 类型
true == 2; // false

![] == []; // true，因为 ! 的优先级要高于 ==，因此会先将 ![] 转为 false，再转为 Number 类型

null == undefined; // true，除此之外，null 和 undefined 与任意值进行比较，结果都为 false
```

### + 运算符

- 当一侧为 `String` 类型，另一侧为任意类型，会优先将另一侧的内容转换为 `String` 类型，再进行字符串拼接;
- 当一侧为 `Number` 类型，另一侧为 **原始类型（除 String 外）**，会将另一侧的内容转换为 `Number` 类型，再进行加法运算;
- 当一侧为 `Number` 类型，另一侧为 **引用类型**，会将另一侧的内容转换为 `String` 类型，再进行字符串拼接;

```js showLineNumbers
'123' + {}; // "123[object Object]"
'123' + false; // "123false"

123 + true; // 124

123 + {}; // "123[object Object]"
123 + [456]; // "123456"
```

## 构造函数 & 实例化对象

##### 什么是构造函数?

- **构造函数** 简言之就是一种能 **构造出对象** 的函数，用来初始化对象，为对象成员变量赋予初始值，总与 `new` 关键字一起使用;
- `Array` 是 JS 内置的 **全局对象**，同时它也是一个 **构造函数**，与之相似的还有 `Object`、`String`、`Number` 等内置对象;

```js showLineNumbers
typeof Array; // 'function'
```

##### 什么是实例化对象?

- **实例化对象** 是通过 `new` 关键字来执行一个 **构造函数**，然后返回一个普通对象;
- 通过该对象，可以访问到其对应的构造函数中 定义的内容 或 原型 `prototype` 中定义的内容;

```js showLineNumbers
typeof new Array(); // 'object'
```

##### 构造函数中的返回值

- 构造函数默认返回的是该函数的 `this`;
- 若构造函数中没有指定返回值，或指定的返回值为 **原始类型**，则该返回值是无效的，其对应的实例化对象可以直接访问该函数中 **通过 `this` 定义的内容** 或 **通过 `prototype` 定义的内容**;
- 若构造函数返回了一个 **引用类型**，则实例化对象 **只能访问该引用类型的值**;

```js showLineNumbers
// 创建一个构造函数 & 实例化对象，返回一个 原始类型
function Person() {
  this.name = 'dino';
  return '😄😄😄';
}
Person.prototype.age = 26;
const p = new Person();
p.name; // 'dino'
p.age; // 26

// 创建一个构造函数 & 实例化对象，返回一个 引用类型
function Person_1() {
  this.name = 'dino';
  return { name: '大脸脸' };
}
Person.prototype.age = 26;
const p1 = new Person_1();
p1.name; // '大脸脸'
p1.age; // undefined
```

##### `new A()` 在执行的过程中发生了什么?

- 创建了一个 **空对象**(新建了一个内存空间)，让该对象的 `__proto__` 指向 构造函数 A 的 `prototype`;
- 改变 `this` 指向，让原本指向 `window` 的绑定对象 `this`，指向刚创建好的 空对象;
- 执行构造函数中 A 中的代码，给这个新对象添加属性或方法;
- 返回这个新对象;

:::caution 如何手动实现一个 `new`?

```js title="代码实现" showLineNumbers
function newOperator(fn, ...args) {
  // args 表示剩余参数集合
  // 创建一个新对象 obj，让它的原型链 __proto__ 指向 fn.prototype 对象
  const obj = Object.creat(fn.prototype);
  // 或
  // const obj = {};
  // Object.setPrototypeOf(obj, fn.prototype);  // 为 obj 对象设置一个原型

  console.log(obj.__proto__ === fn.prototype); // true

  // 改变 this 指向，使 obj 能访问到 fn 函数中的属性或方法
  // 构造函数中的 返回值是什么，ret 就是什么；如果没有返回值，则 ret 为 undefined
  const ret = fn.bind(obj)(...args);
  // 或
  // const ret = fn.call(obj, ...args);
  // 或
  // const ret = fn.apply(obj, args);

  // 返回 新对象 obj
  return typeof ret === 'object' ? ret : obj;
}

// 调用
function Person(name) {
  this.name = name;
}
const p = newOperator(Person, 'dino');
p.name; // 'dino'
```

:::

:::tip 参考资料

- 👉 [实例对象与 new 命令](https://wangdoc.com/javascript/oop/new.html)

:::

## 原型 & 原型链 📦

##### `prototype` 对象

- **所有 函数** 都具有(**独有**) `prototype` 属性(显式原型)，它是一个普通对象，也称为 **原型对象**;
- **所有 构造函数** 的 **实例化对象** 都可以在该函数的 `prototype` 中找到定义的公用属性或方法;

```js showLineNumbers
// 创建一个构造函数 & 实例化对象
function Person(name) {
  this.name = name;
}
Person.prototype.age = 26; // 定义可公用的属性或方法

const p = new Person('dino');

p.name; // 'dino'
p.age; // 26
```

##### `__proto__` 对象

- **所有 对象** (JS 万物皆对象)都具有一个 `__proto__` 属性(隐式原型)，也称为 **原型链对象**，它 **指向该对象的 构造函数 的 `prototype`**;

```js showLineNumbers
new Array().__proto__ === Array.prototype; // true
new Object().__proto__ === Object.prototype; // true
new Function().__proto__ === Function.prototype; // true

const obj = { name: 'dino' }; // 创建对象时，实质上是执行了 new Object({ name: 'dino' })
obj.__proto__ === Object.prototype; // true
```

- **所有 对象** 的 **原型链** 会逐层的向上查找，最终都会指向 `Object.prototype`，而原型链的尽头，则为 `null`;

```js showLineNumbers
Array.prototype.__proto__ === Object.prototype; // true
Function.prototype.__proto__ === Object.prototype; // true

// 原型链的 尽头
Object.prototype.__proto__ === null; // true
```

##### `constructor` 属性

- **所有 对象** 都具有一个 `constructor` 属性，它 **指向该对象的 构造函数**;

```js showLineNumbers
[].constructor === Array; // true
({ name: 'dino' }.constructor === Object); // true
(123).constructor === Number; // true
```

:::tip 参考资料

- 👉 [js 的原型和原型链是什么 - php 中文网](https://m.php.cn/article/462738.html)

:::

## this 关键字

##### `this`

##### `call()` 和 `bind()`

:::tip 参考资料

- 👉 [this 关键字 - 网道文档](https://wangdoc.com/javascript/oop/this.html)

:::

## 闭包

## JS 事件循环机制 📦

## JS 设计模式 📦
