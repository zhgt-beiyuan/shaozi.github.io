---
title: 前端鉴权 方式
id: authentication
toc_max_heading_level: 4
---

```mdx-code-block
import { Image } from '@arco-design/web-react';
```

> 本章节会简单的介绍前端和服务器之间用于 **身份认证**、**授权** 等一些鉴权类的方式，如 Cookie、Session、Token 等方式

:::info 前言

- 由于 http 是 `无状态` 的，**对事务处理没有记忆能力，每次客户端和服务器会话完成时，服务器不会保存任何会话信息**，且每个请求都是独立的，这样服务器就无法确认当前访问者的身份，无法分辨上一次和当前的请求发送者是不是同一个客户端;
- 因此服务器和客户端为了进行**会话跟踪**(知道是谁在访问)，就必须主动去维护一个**状态**(类似于给每人发一张身份证);
- 有了状态之后，就需要将状态**存储**在客户端，以便和服务器持续会话，用来告知服务器前后两个请求是否来自于同一客户端(类似于自己将身份证管理好，当需要出去办事时，再将身份证带出去，以证明是本人，才能继续操作);

:::

## 基石 - Cookie

##### 什么是 Cookie?

- cookie 是 http **请求头** 中的字段，也是 **前端存储的一种方式**，它 **存储在客户端**;
- cookie 是服务器发送到客户端的一小块数据(可以包含用户信息，其他交互信息等)，它会在客户端下一次请求时携带并发送到服务器上；然后服务器会根据该值，来判断请求是否来自于同一客户端，从而保持 **会话(登录)状态**;
- cookie 是 http `无状态` 特点的一种补充和改良;

##### 设置 Cookie

- 服务器可以通过 **响应头** 中的 `Set-Cookie` 字段，将 cookie 的值放到客户端;
- 客户端可以通过 JS 脚本(如: `document.cookie`、`XMLHttpRequest` 等)来设置 cookie;
- 设置 cookie 时，要以 `key=value`(键值对) 的形式来设置，并且都是 **字符串** 类型，然后客户端在发起请求时，会将每一个 cookie 拼接起来，用 `;` 分隔，组成一段文本，发送给服务器，如下图;

<Image src={require('./img/http-cookie.jpg').default} width='80%' />

##### Cookie 的一些属性

| 属性       | 描述                                                                                                                                                                                                                                                                                                 |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Domain`   | 指定 cookie 所属/绑定 的域名，默认为当前域名                                                                                                                                                                                                                                                         |
| `Path`     | 指定 cookie 在哪个路径下生效，默认是 `/`，前提是域名一致                                                                                                                                                                                                                                             |
| `Expires`  | 🔅 它是 UTC 格式的时间字符串，给 cookie 设置 **到期时间**，到设置的时间点后，cookie 会自动失效; <br />❗️ 客户端是根据系统时间来决定 cookie 是否过期，而系统时间是不精确的(可以人为修改)，所以无法保证 cookie 一定会在服务器指定的时间过期                                                           |
| `Max-Age`  | 🔅 它代表 cookie 的 **失效时间**，单位为 **秒**，默认为 `-1`; <br />🔅 如果该值为 **正数**，则 cookie 将在 `Max-Age` 秒后失效; <br />🔅 如果该值为 **负数**，则 cookie 为 **临时(会话) cookie**，关闭浏览器即失效; <br />🔅 如果该值为 `0`，则删除该 cookie; <br />🔅 **该值的优先级大于 `Expires`** |
| `Secure`   | 🔅 指定 cookie 是否只能在安全加密协议(HTTPS)下传输; <br />🔅 它是一个 **Boolean** 类型，默认为 `false`; <br />🔅 如果设置了该值，cookie 在 HTTP 中是无效的；且如果当前是 HTTPS，该值会自动生效;                                                                                                      |
| `HttpOnly` | 🔅 是否允许通过 JS 脚本获取 cookie 信息，目的是防止 **XSS 攻击**; <br />🔅 它是一个 **Boolean** 类型，默认为 `false`; <br />❗️ 即便设置了该值，还是能通过浏览器的 **Application** 工作台对 cookie 进行修改，所以它并不是绝对的安全;                                                                 |

:::info 离离原上谱

- 在设置 cookie 时，如果同时指定了 `Expires` 和 `Max-Age` 属性，则 `Max-Age` 的值将优先生效; 如果二者都没有指定，则表示该 cookie 为 **临时(会话) cookie**，当浏览器关闭时，cookie 随即失效;

:::

##### Cookie 的缺点

- 每个域名下 **最多只能有 20 条 cookie**，且每个 cookie 的长度 **大小不能超过 `4KB`**，否则内容会被截取掉(目前部分主流浏览器可支持到 8 KB);
- 由于在 http 请求中，cookie 的值是明文显示的，且存储在客户端，所以就会 **存在安全风险**，内容可能会被篡改或截取;
- cookie 默认是 **不可跨域** 的，每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用(子域名是可以共享的);
- 移动端对 cookie 的支持不是很友好;

:::info 离离原上谱

- Chrome 浏览器默认是不允许携带 cookie 的，在 `<= 90` 版本的浏览器中，需手动设置以下内容(在地址栏输入 [_chrome://flags_](chrome://flags))，才能允许浏览器跨域携带 cookie，以防产生 **跨域的报错问题**;

<Image src={require('./img/http-cookie-3.jpg').default} width='90%' />

- 👉 [面试官 -- 跨域请求如何携带 cookie? - 微信](https://mp.weixin.qq.com/s/a9iLWiSgeKuUIYVaWXordw)

:::

## Session {#session}

##### 什么是 Session?

- 由于 cookie 是明文传输的，如果要验证用户身份时，必然是不能将用户信息存入到 cookie 中进行验证的，这时需要服务器单独维护一个状态来进行校验，这个状态就是 **Session**;
- session 是基于 cookie 实现的，它 **存储在服务端**，且可以存储 **任意数据类型**;

##### 使用 Cookie + Session 的方式进行 登录/身份验证 的主要流程

- 用户登录时，服务器拿到用户的登录信息，先去用户数据库中进行校验，校验成功后创建其对应的 Session 信息表;
- Session 创建成功之后，在响应中将此 Session 的唯一的标识信息 `SessionId` **存到 cookie 中** 并返回给客户端;
- 客户端再次发起请求时，服务端会根据 cookie 中携带的 `SessionId` 来查找其对应的 Session 信息，如果没有找到则登录失效; 找到则可继续操作;

<Image src={require('./img/http-cookie-1.jpg').default} width='80%' height={360} />

##### Session 的缺点

- 由于 Session 是存在服务器中的，当访问量过多时，会占用过多的服务器资源;
- 当服务器做了负载均衡时，Session 容易失效，比如 服务器 A 存储了 Session，做了负载均衡后，服务器 A 的访问量会被转发到服务器 B 上，但是 B 没有存储 Session，这样就会导致 Session 的失效;

:::info 离离原上谱

_🙃 问:_

`SessionId` 是存储在 cookie 中的，假如浏览器禁用 cookie 怎么办?

_😶 答:_

当浏览器把 cookie 禁用掉之后，一般会把 `sessionId` 跟在 `url` 的参数后面，即重写 url，让服务端能拿到 `sessionId`;

:::

## Token

##### 什么是 Token?

- 由于 Session 的维护给服务端带来很多困扰，比如资源的占用，存储的问题等，所以需要一种既不占用服务器资源，又可以进行身份认证的方式，该方式就是 **Token**;
- Token 也称为 **令牌**、**访问服务器资源的凭证**，且它是 **无状态** 的;
- Token 主要由 **`uid`(用户的唯一身份标识)** + **`time`(当前时间的时间戳)** + **`sign`(签名，一种 hash 算法压缩而成的字符串)** 组成;

##### 使用 Cookie + Token 进行身份验证的主要流程

- 用户登录时，服务端拿到登录信息后，先去用户数据库中进行校验，校验成功后，将 **登录信息做成数字签名，再进行加密**，然后得到 token;
- 服务器响应时，再将 token **存到 cookie 中**，或者通过一个特定的接口来返回 token，可以让客户端取到该值;
- 客户端再次发起请求时，服务端会去验证 cookie 中携带的 token，验证成功即可继续操作;

<Image src={require('./img/http-cookie-2.jpg').default} width='80%' height={360} />

##### Token 的特点

- 基于 token 的身份认证是一种服务端 **无状态** 的认证方式，因为服务端不用存储 token，用解析(解密) token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的数据库查询;
- Token 的安全性相比于 Session 要更好一些，它有加密，有签名;
- Token 可以避开同源策略，支持移动端设备，支持跨程序调用;
- Token 完全可以 **替代 Cookie + Session 的方式** 对身份进行认证/校验/授权;
- Token 可以有效避免 **CSRF** 攻击;

##### Access Token 和 Refresh Token

- 通常 **业务接口用来鉴权的 Token** 称为 `Access Token`，它的有效期都很短，尤其是涉及到敏感权限的业务，但是这样对用户的体验就不是很友好(有效期短，只能重新登录来获取新的 token);
- 这时可以选择再添加一个 token，一个用来 **更新 access token** 的 token，也就是 `Refresh Token`;
- 当 access token 过期后，就可以使用 refresh token 再生成一个新的 token，这样既能保证业务的安全性，还能提高用户的体验；当 refresh token 也过期时，就只能重新登录了;

## JWT

- JWT 全称是 `JSON Web Token`，也称为 **Json 令牌**，和 Token 一样，都是 **无状态** 的，都是 **访问资源的凭证**;
- JWT 是目前最流行的 **跨域身份认证** 的解决方案;
- JWT 中存储的信息是安全的，因为是经过数字签名的，因此可以被信任，可以使用一些算法对 JWT 进行签名;
- 更多内容可查看 👉 [_JSON Web Token(JWT) 入门教程 - 阮一峰_](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)

## 总结 📦

### Cookie 和 Session 的区别

|                       | `Cookie`                                                                                | `Session`                                        |
| --------------------- | --------------------------------------------------------------------------------------- | ------------------------------------------------ |
| **存储位置**          | 客户端                                                                                  | 服务端                                           |
| **安全性**            | 一般，因为信息存储在客户端，可以被拦截或伪造                                            | 较好，因为信息存储在服务端                       |
| **存值的类型**        | 字符串                                                                                  | 任意类型                                         |
| **有效期**            | 可设置较长时间的有效期                                                                  | 较短                                             |
| **存值的容量 & 大小** | 一般浏览器都限制单个域名下的 cookie 不能超过 20 条，且每个 cookie 的长度大小不超过 `4K` | 无限制，但当访问量过多时，会占用服务器过多的资源 |
| **存值的多样性**      | 只能存储在 客户端                                                                       | 可存储在 Redis、数据库等                         |
| **对移动端的支持性**  | 不友好                                                                                  | 由于是基于 Cookie 实现的，所以也不友好           |

### Token 和 JWT 的区别

|                               | `Token`                                                                                | `JWT`                                                                                                                              |
| ----------------------------- | -------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| **访问资源的令牌 & 记录信息** | ✅                                                                                     | ✅                                                                                                                                 |
| **无状态(无需存储)**          | ✅                                                                                     | ✅                                                                                                                                 |
| **安全性**                    | 较好，对信息进行加密                                                                   | 较好，对信息进行加密                                                                                                               |
| **验证流程**                  | 服务端验证客户端发来的 token 时，**还需查询数据库**获取用户信息，再验证 token 是否有效 | 将 Token 和 Payload(用户信息或其他数据) 加密后存储于客户端，服务端只需要使用密钥解密进行校验即可，**不需要查询或者减少查询数据库** |
| **对移动端的支持性**          | 友好                                                                                   | 友好                                                                                                                               |

## 参考资料

- 👉 [前端鉴权的兄弟们：cookie、session、token、jwt、单点登录 - 掘金](https://juejin.cn/post/6898630134530752520)
- 👉 [傻傻分不清之 Cookie、Session、Token、JWT - 掘金](https://juejin.cn/post/6844904034181070861)
- 👉 [看完这篇 Session、Cookie、Token、JWT，和面试官扯皮就没问题了 - 掘金](https://juejin.cn/post/6844904115080790023#heading-11)
- 👉 [Token 身份认证优缺点分析以及常见问题解决方案 - 腾讯云](https://cloud.tencent.com/developer/article/1519926)
