---
title: HTTP & HTTPS 协议
id: http
toc_max_heading_level: 4
---

```mdx-code-block
import { Image, Timeline, Typography } from '@arco-design/web-react';
import { IconClockCircle } from '@arco-design/web-react/icon';
```

> http 和 https 是在开发中最常用的知识点，本章节内容会参考其他资料，对 http 的知识点做一个简单的总结

<!--
<Image src={require('./img/HTTP.png').default} style={{ maxHeight: 'initial' }} />
-->

<Image src='//aone-time.icu/group1/dino/column-service/HTTP.png' style={{ maxHeight: 'initial' }} />

## HTTP 基础

### 前言

##### 什么是 TCP 协议?

TCP 协议也称 **传输控制协议**，是一种面向连接的、可靠的、基于字节流的传输层通信协议，并且每一个 TCP 的连接都需要经历 **三次握手建立连接** 和 **四次挥手断开连接**;

##### 什么是 HTTP 协议?

- HTTP 协议也称 **超文本传输协议**，是建立在 TCP 协议上的，位于 TCP/IP 网络模型当中的 **应用层**，是从 Web 服务器发送 **HTML(超文本标记语言)** 到本地浏览器的传输协议;
- HTTP 协议通过 **请求 / 响应** 的方式，在客户端和服务端之间进行通信;

:::tip 参考资料

- 👉 [一篇搞懂 TCP、HTTP、Socket、Socket 连接池 - 思否](https://segmentfault.com/a/1190000014044351)
- 👉 [深入理解 TCP/IP 模型](https://zhuanlan.zhihu.com/p/33797520)
- 👉 [OSI 7 层模型和 TCP/IP 4 层模型 - 知乎](https://zhuanlan.zhihu.com/p/32059190)

:::

### HTTP 特点 & 缺点

##### 特点(主要为 http 1.0 版本):

- `灵活` 通过 http 协议中头部的 <code>Content-Type</code> 标记，可以传输任意类型的数据对象（文本，图片，视频等）;
- `简单快速` 客户端向服务端发起请求时，只需传送请求方法和路径即可，使用简单，通信速度较快;
- `无连接` 每次请求只连接一次，请求结束即断开连接，不会一直保持连接，所以无法实现客户端与服务器保持会话连接的状态;
- `无状态` 每次请求都是 <b>独立的</b>，请求结束后不会保留或记录任何信息，减少了网络开销，这 <b>既是优点也是缺点</b>;
- `串行队列` http 采用的是 **请求 - 应答** 模式，并且报文必须是 **一发一收**，这就形成了一个 **先进先出** 的串行队列;

##### 缺点:

- `无状态` 由于每次请求都是独立的，当后续如果需要之前请求的信息时，则必须重新发起请求，可能会导致每次传送的数据量增大;
- `明文传输 & 不安全` 由于 HTTP 协议中的报文(主要是 header 部分)不是使用的二进制数据，而是明文文本的形式，这样就可能会导致信息被窃取等不安全的行为;
- `队头阻塞` 由于 http `串行队列` 的特点，排在前面的请求要最先处理，如果队首的请求耗时过长，后面的请求就会有 **阻塞** 的现象;

### HTTP 报文结构

HTTP 报文由 **请求报文** 和 **响应报文** 两部分组成;

##### 请求报文 结构

- `请求行` 包含 http 请求方法、请求地址路径、协议 & 版本;
- `请求头(Request Headers)` 就是用一些 `key: value` 的形式来告知服务端要注意或需要什么信息;
- `空行` 用来区分 **头部** 和 **实体**，当服务端解析遇到空行时，就知道下一个不再是请求头部分，会自动当成是请求体解析;
- `请求体` 客户端发起请求时需传递的参数;

##### 响应报文 结构

- `状态行` 包含 http 协议及版本、响应状态码、状态码名称;
- `响应头(Response Headers)` 同 **请求报文** 中的 `请求头` 一致，只是它用来告诉客户端一些信息;
- `空行` 同 **请求报文** 中 `空行` 的作用一致;
- `响应体` 服务端返回的数据;

### HTTP 请求/响应头 字段

- 在 请求/响应头 中，字段名是 **不区分大小写** 的;
- 如果要给某字段定义多个值时，可用 **逗号** 分割值; **分号** 分割值的参数;
- 字段值的参数 `q` 代表优先级，取值范围是 `[0-1]`，默认为 `1`，也就是优先级最高;

```bash title="Request Headers 示例值"
Accept: audio/*;q=0.2, audio/basic

# 其中 audio/basic 类型的资源优先级最高，会优先处理；如果没有，则会处理任意格式的 audio 资源
```

##### Request Headers 部分字段

| Headers 字段      | 描述                                                                                                                                                                       | 示例值                                                                                                                                                                |
| ----------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Accept`          | 指定客户端可以处理 / 接收的 **内容(MIME 媒体)类型**                                                                                                                        | `*/*`(任意类型)<br />`application/*`(二进制数据)<br />更多类型可查看 [_MIME 类型 - MDN_](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types) |
| `Accept-Charset`  | 指定浏览器可以处理的 **字符集编码类型**                                                                                                                                    | `utf-8`                                                                                                                                                               |
| `Accept-Encoding` | 指定浏览器可以支持的内容 **压缩编码类型**                                                                                                                                  | `gzip, deflate, br`                                                                                                                                                   |
| `Accept-Language` | 指定浏览器可接收的 **语言类型**                                                                                                                                            | `zh-CN, zh;q=0.9`                                                                                                                                                     |
| `Cache-Control`   | http 1.1 新增的字段，是 **通用消息头字段**，用来控制请求或响应的 [_缓存_](#http-cache) 机制                                                                                | `no-cache`                                                                                                                                                            |
| `Connection`      | 指定是否需要长连接(http 1.1 默认支持长连接)                                                                                                                                | `keep-alive`(开启长连接)<br />`close`(关闭长连接)                                                                                                                     |
| `Cookie`          | 🍏 为了浏览器和服务器之间进行 **会话跟踪** (知道是谁在访问服务器)，而维护的一个状态，一段 txt 文本;<br />🍏 进行请求时，会把保存在该域名下的所有 cookie 值一起发送给服务器 | `_zap=7dea80c8; ...`                                                                                                                                                  |
| `Content-Type`    | 指定请求体的 **内容(MIME 媒体)类型** 和 **字符集编码类型**，是 `Accept` 和 `Accept-Charset` 字段的集合                                                                     | `application/json; charset=UTF-8`                                                                                                                                     |
| `Content-Length`  | 请求体内容的长度，为 `number` 类型                                                                                                                                         | --                                                                                                                                                                    |
| `Host`            | 指定请求发送到服务器的主机名和端口号(http 1.1 中必须要包含该字段)                                                                                                          | --                                                                                                                                                                    |
| `Referer`         | 表示请求的发起来源地址，也就是当前页面资源的 **上一级页面地址 url**，适用于网页的数据统计分析，日志记录，缓存优化等                                                        | --                                                                                                                                                                    |
| `User-Agent`      | 发起请求时携带的 **客户端信息**，一般包含浏览器，浏览器内核和操作系统的版本型号等信息                                                                                      | `Mozilla/5.0 ...`                                                                                                                                                     |

##### Response Headers 部分字段

| Headers 字段       | 描述                                                             | 示例值                            |
| ------------------ | ---------------------------------------------------------------- | --------------------------------- |
| `Content-Encoding` | 服务器返回的实体内容(响应体)可支持的 **压缩编码类型**            | `br`                              |
| `Content-Type`     | 服务器返回的实体内容的 **(MIME 媒体)类型** 和 **字符集编码类型** | `application/json; charset=utf-8` |
| `Content-Language` | 服务器返回的 **语言类型**                                        | `zh-CN`                           |
| `Server`           | 服务器所用的 **软件相关信息**                                    | `Apache/2.4.1 (Unix)`             |
| `Via`              | **代理服务器** 常用字段，表明代理服务器的身份                    |                                   |

:::tip 参考资料

- 👉 [HTTP Header 字段文档 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Charset)
- 👉 [HTTP header 详解 - 博客园](https://kb.cnblogs.com/page/92320/)
- 👉 [鲜为人知的 HTTP 协议头字段详解 - 掘金](https://juejin.cn/post/6844903582362238989#heading-42)

:::

### HTTP 请求方法

有以下 9 种请求方法:

| 请求方法  | 描述                                                                                                            | http 1.1 新增 | 幂等性 |
| --------- | --------------------------------------------------------------------------------------------------------------- | ------------- | ------ |
| `GET`     | 请求指定的服务器资源，参数 拼在 url 后面                                                                        |               | ✅     |
| `POST`    | 向指定资源提交数据并进行处理（如表单提交，文件上传等），通常会造成服务器资源的修改，参数 被包含在 **请求体** 中 |               |        |
| `HEAD`    | 类似于 `GET` 请求，只不过返回的响应中没有具体的内容，用于获取报文头部                                           |               | ✅     |
| `PUT`     | 请求服务器 **创建/更新** 指定的资源                                                                             | ✅            | ✅     |
| `DELETE`  | 请求服务器 **删除** 指定的资源                                                                                  | ✅            | ✅     |
| `CONNECT` | 将连接改为管道方式用于代理服务器                                                                                | ✅            |        |
| `OPTIONS` | 允许客户端查看服务器的性能，列出指定资源支持的请求方法                                                          | ✅            | ✅     |
| `TRACE`   | 回显(追踪)服务器收到的请求，主要用于测试或诊断                                                                  | ✅            |        |
| `PATCH`   | 是对 `PUT` 方法的补充，用来对指定资源进行 **局部更新**                                                          | ✅            |        |

:::info 什么是 **幂等性**?

- **幂等** 表示执行一次或多次请求，产生的效果(结果)都是一样的，都具有一样的副作用，且不会对服务器资源产生影响; 如 列表数据的查询和详情操作;
- `PUT` 请求在更新资源时，会将数据直接替换到服务器中，多次调用它，产生的效果都是一样的，所以它满足幂等性;

:::

#### `GET` 和 `POST` 请求的区别

本质上其实就是 **语义** 不同;

|                     | `GET`                                                                                            | `POST`                                       |
| ------------------- | ------------------------------------------------------------------------------------------------ | -------------------------------------------- |
| **参数**            | 通过 `URL` 传递                                                                                  | 放在 `请求体` 中                             |
| **参数长度 & 大小** | 长度会有限制(各浏览器限制不同)，数据大小一般不能大于 2KB                                         | 无限制                                       |
| **参数编码**        | 进行 URI 编码，只能接收 `ASCII` 字符，会将汉字，空格等字符转义为十六进制字节符，并在前面加个 `%` | 支持多种编码方式                             |
| **安全性**          | 由于参数是暴露在 URL 中的，因此不安全，适合做一些查询类的请求                                    | 安全性较高，更适合做一些敏感类的数据传输请求 |
| **缓存**            | 请求会被浏览器主动缓存，留下历史记录                                                             | 请求则需要手动设置才会被缓存                 |
| **幂等性**          | ✅                                                                                               |                                              |

:::tip 参考资料

- 👉 [_HTTP 总结 - GET 和 POST - 掘金_](https://juejin.cn/post/6992933721703710750)
- 👉 [_ASCII 码表(以 ASCII 打印字符为主)_](https://habaijian.com/)

:::

### HTTP 状态码 📦

HTTP 状态码可分为以下 **五类**:

- `1xx` **信息响应**(100-199)，表示服务器收到请求，需要执行者继续请求
- `2xx` **成功响应**(200-299)，表示请求已被成功接收 & 处理
- `3xx` **重定向**(300-399)，表示要完成请求还需进一步操作
- `4xx` **客户端错误**(400-499)，表示请求有语法错误或请求无法实现
- `5xx` **服务端错误**(500-599)，表示服务器在处理请求中发生了错误

常见状态码如下:

| 状态码 | 状态码英文名称        | 描述                                                                                                           |
| ------ | --------------------- | -------------------------------------------------------------------------------------------------------------- |
| `200`  | OK                    | 请求成功，一般用于 `GET` 或 `POST` 请求                                                                        |
| `204`  | No Content            | 请求成功，但服务器未返回内容                                                                                   |
| `206`  | Partial Content       | 表示服务器成功处理了部分请求，一般为响应头带 `Range` 的请求，场景有 [_HTTP 大文件传输_](#http-big-file-upload) |
| `301`  | Moved Permanently     | **永久** 重定向，请求的资源已被永久的移动到新的 url，浏览器会自动重定向到新 url                                |
| `302`  | Found                 | **临时** 重定向，请求的资源被临时移动，客户端应继续使用原来的 url                                              |
| `304`  | Not Modified          | 请求资源未修改，服务器不会返回任何资源，此时客户端通常会访问缓存过的资源                                       |
| `400`  | Bad Request           | 请求的语法错误，导致服务器无法解析，如: 参数错误                                                               |
| `401`  | Unauthorized          | 一般为 **无权限** 访问，服务器要求客户端提供身份认证                                                           |
| `403`  | Forbidden             | 服务器收到了客户端的请求，但是拒绝执行该请求，如: 法律要求，信息敏感等                                         |
| `404`  | Not Found             | 请求资源不存在，如: 请求路径错误                                                                               |
| `405`  | Method Not Allowed    | 请求方法被服务器禁止                                                                                           |
| `500`  | Internal Server Error | 服务器内部错误，无法完成请求                                                                                   |
| `503`  | Service Unavailable   | 服务器暂时无法处理客户端的请求，比如服务器 过载，宕机或维护等                                                  |

:::tip 参考资料

👉 [_HTTP 状态码 - 菜鸟教程_](https://www.runoob.com/http/http-status-codes.html)

:::

### HTTP 长连接/持久连接 {#long-connection}

- `HTTP 1.1` 版本开始默认支持 **长连接**，又称持久连接，在客户端发起请求时，只需要建立一个 TCP 连接即可，使客户端到服务端的连接持续有效，多个 http 请求/响应会共用这一个 TCP 连接通道，避免了重新建立连接，提升了传输效率;
- 在 **请求头** 中添加 `Connection: Keep-Alive` 属性，即可开启 长连接;

<!--
<Image src={require('./img/http-long-connection.jpg').default} height={360} width='60%' />
-->

<Image
  src='//aone-time.icu/group1/dino/column-service/http-long-connection.jpg'
  height={360}
  width='60%'
/>

##### 长连接的优点

- 减少 CPU 及内存的使用;
- 减少了后续请求的响应时间，提升传输效率;
- 支持 [_管道化_](#pipeline) 的请求及响应**模式**;
- 减少了网络堵塞;
- 发生错误时，也可在不关闭连接的情况下进行错误提示;

##### 如何避免长连接资源浪费?

- 在客户端的 **请求头** 中声明 `Connection: close`，在本次通信后就关闭连接，也就是不开启 长连接;
- 在服务端配置，如 **nginx**，设置 `keepalive_timeout`，指定长连接的的超时时间；设置 `keepalive_requests`，指定长连接请求次数的上限;

### HTTP 管道(线)化 模式 {#pipeline}

- 管道化连接 是 `HTTP 1.1` 中 [_长连接_](#long-connection) 支持的一种 **连接模式、特性**，也称 管道化持久连接;
- 该模式是在同一个 TCP 连接中 **发一个请求不必等其响应，就可继续发其他请求**，也就是并发的状态，可以减少整体的响应时间，提高吞吐，但服务器还是会 **按照请求的顺序依次响应**;
- 非管道化和管道化连接的状态如下:

<!--
<Image src={require('./img/2022-04-07-pipeline.jpg').default} height={360} width='60%' />
-->

<Image
  src='//aone-time.icu/group1/dino/column-service/2022-04-07-pipeline.jpg'
  height={360}
  width='60%'
/>

- 如果请求较多时，排在前面的请求响应很慢，就会产生 [_队头阻塞_](#team-head) 问题;

##### 管道化连接的特点

- 只能以管道化的方式发送 **幂等请求(GET, HEAD 等)**，而不是 **非幂等请求(POST 等)**，否则，当传输连接过早终止时，会造成一些不确定的后果;
- 管道化模式中，响应的顺序就是请求的顺序，因为 http 的请求和响应没有序号标识;
- 由于管道化本身可能会产生 [_队头阻塞_](#team-head) 的问题，现代浏览器默认都关闭了该模式，并且大部分服务器也是默认不支持的;

### HTTP 队头阻塞 问题 {#team-head}

- **队头阻塞与长连接/短连接并无关系**，是由于 http `串行队列` 的特点，排在前面的请求要最先处理，如果队首的请求耗时过长，则后面的请求就会有 **队头阻塞** 的现象;;
- 在 `非管道化长连接` 中的表现:
  - 客户端发起请求时，如果前面的请求耗时过久，则后面的请求就会被阻塞，无法发起，可见其队头阻塞发生在 **客户端**;
- 在 `管道化长连接` 中的表现:
  - 由于管道化连接中的响应顺序就是请求顺序，所以前面的请求处理耗时较久，则响应生成也慢，就会阻塞其他已经生成的响应，可见其队头阻塞发生在 **服务端**;

##### 如何解决队头阻塞问题?

- `并发长连接` 这里的并发长连接指的是 **TCP 并发长连接**，因为一个域名允许分配多个长连接(Chrome 6 个 / Firefox 8 个)，相当于增加了任务队列，不至于一个队列中的任务阻塞其他全部任务;
- `域名分片` 由于一个域名可以并发 6 ~ 8 个长连接，那么还可以再准备几个 **子级域名**，可以让不同的资源从不同的域名中获取，再指向同一台服务器，这样就能够并发更多的长连接了;

### HTTP 大文件传输 & 下载 {#http-big-file-upload}

http 对大文件的传输有以下几种方式，只做简单的介绍了解，具体可查看下方参考资料:

##### 数据压缩(传输)

- 客户端可以设置请求头中的 `accept-encoding` 字段来告诉客户端可以支持哪些压缩方式对数据、文件进行压缩，比如 `gzip(对文本文件有较好的压缩率)`、`br(专门为 HTML 设计的压缩方式)` 等;

##### 分块传输(分片上传)

- 简单定义就是: 将文件分成多块，独立传输，上传完成后再合并，需要设置响应头中的 `Transfer-Encoding` 为 `chunked`;

##### 范围请求(传输)

- http 协议中的范围请求是允许服务器只发送 http 消息的一部分到客户端，在传输大的媒体文件，或与 文件下载的断点续传 功能搭配使用时非常有用;
- 可以在请求头中设置 `Range` 字段，来表示在特定单位下(通常是 bytes 字节单位)，请求的范围大小;
- 在响应头中返回 `Content-Range` 字段，表示客户端接收的单位和范围大小;

##### 断点续传(文件下载)

- 简单定义就是: 在文件下载过程中，如果出现暂停或异常中断后，可基于原来的进度继续下载;

:::tip 参考资料

- 👉 [HTTP 传输大文件有哪些方案? - 掘金](https://juejin.cn/post/7005347768491311134)
- 👉 [HTTP 如何传输大文件? - 博客园](https://www.cnblogs.com/traditional/p/15373999.html)
- 👉 [断点续传和分片上传 - 简书](https://www.jianshu.com/p/b1c62273cf82)

:::

## HTTP 进阶

### HTTP 代理

- http 代理是指介于浏览器和服务器之间的一台或多台服务器，也称代理服务器;
- 可以通过代理来访问一些受限制的网站，隐藏自己真是的 IP 地址，提高网站访问的速度和安全性等;
- 常见的代理方式有以下几种:

##### 普通代理(中间人代理)

- 该代理方式就相当于是一个中间人的角色; 它的角色功能如下图所示;
- 它还可以实现一些负载均衡、过滤、缓存的功能;

<!--
<Image src={require('./img/http-agent.jpg').default} width='80%' height={360} />
-->

<Image src='//aone-time.icu/group1/dino/column-service/http-agent.jpg' height={360} width='80%' />

##### 隧道代理

- 由于普通代理服务器无法代理 https 的报文，客户端和代理服务器之间就无法创建 **TLS(安全传输层协议)**，无法支持数据的保密性和安全转发;
- 隧道代理则解决了上述的问题，客户端发送 `CONNECT` 请求到代理服务器，然后和真实服务器之间建立 TCP 连接，创建成功之后客户端就可以和真实服务器进行数据的直接转发，加密传输，如下图;

<!--
<Image src={require('./img/http-agent-1.jpg').default} width='80%' height={360} />
-->

<Image src='//aone-time.icu/group1/dino/column-service/http-agent-1.jpg' height={360} width='80%' />

:::tip 参考资料

👉 [HTTP 隧道代理原理和实现](https://cizixs.com/2017/03/22/http-tunnel-proxy-and-golang-implementation/)

:::

##### 正向代理

- 工作在 **客户端** 的代理为正向代理，也就是需要在客户端配置相关的代理服务器的信息，它可以隐藏真实的客户端，比如抓包工具及访问外网的代理插件等;
- 正向代理通常用于访问一些无法访问的网站，屏蔽不健康的网站等;

<!--
<Image src={require('./img/http-agent-2.jpg').default} width='80%' height={360} />
-->

<Image src='//aone-time.icu/group1/dino/column-service/http-agent-2.jpg' height={360} width='80%' />

##### 反向代理

- 工作在 **服务端** 的代理为反向代理，无需在客户端中配置代理服务器，它可以隐藏真实的服务器，比如 nginx 代理;
- 反向代理通常用于负载均衡，服务端缓存，流量隔离等;

<!--
<Image src={require('./img/http-agent-3.jpg').default} width='80%' height={360} />
-->

<Image src='//aone-time.icu/group1/dino/column-service/http-agent-3.jpg' height={360} width='80%' />

:::tip 参考资料

👉 [http-proxy 源码解析以及实现(正向代理 & 反向代理理解) - github](https://github.com/hua1995116/proxy)

:::

### HTTP 缓存 📦 {#http-cache}

- http 缓存是 web 性能优化的重要手段，通过复用缓存资源，可以减少客户端和服务器之间的沟通成本，减少客户端的等待时间和网络流量，缓解服务器的压力;
- http 的缓存策略分为两种: [_强缓存_](#strong-cache) 和 [_协商缓存_](#consult-cache);

#### 强缓存 {#strong-cache}

- 强缓存简单定义就是，**强制性的直接使用缓存**;
- 强缓存不会再向服务器发起请求，直接从缓存中读取资源(第一次发起请求除外);
- 在 Chorme 浏览器中，强缓存被分为 `disk cache`(存放在硬盘中) 和 `memory cache`(存放在内存中)，存放的位置是由浏览器控制的，当使用强缓存时，会在 **状态码(Status Code)** 的旁边显示 `from disk cache` 或 `from memory cache`，如下图;

<!--
<Image src={require('./img/http-cache.jpg').default} width='60%' height={360} />
-->

<Image src='//aone-time.icu/group1/dino/column-service/http-cache.jpg' height={360} width='60%' />

- 强缓存的缓存策略是由以下几个 **请求/响应头字段** 所控制的;

##### `Expires` 字段

- 该字段是一个 **响应头** 字段，是 UTC 格式的时间字符串，在浏览器发起请求时，会根据系统时间和该值进行比较，如果 **系统时间大于该值，则缓存失效**;
- 由于是和系统时间进行比较，当系统时间和服务器时间不一致的时候，缓存就会有误差，因此该字段的 **优先级是最低的**;

##### `Cache-Control` 字段

- 它是一个 **通用字段**，在请求头和响应头中都能使用，主要用来表示 **资源缓存的最大有效时间**，即在该时间段内，客户端不需要向服务器发送请求;
- 该字段的 **优先级高于 `Expires`**
- 它的部分属性及介绍如下，更多属性可查看 [_Cache-Control - MDN_](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control) :

| 属性                  | 描述                                                                           |
| --------------------- | ------------------------------------------------------------------------------ |
| `public`              | 表明响应可以被任意对象缓存，如 代理服务器，CDN 等                              |
| `private`             | 表明响应只能被单个用户缓存，不能作为共享缓存(如 代理服务器，CDN 等)            |
| `no-cache`            | 不使用强缓存，需要与服务器进行协商缓存验证                                     |
| `no-store`            | 不应存储关于客户端请求或服务器响应的任何内容，即不使用任何缓存(包括协商缓存)， |
| `max-age=<seconds>`   | 设置缓存存储的最大周期，超过这个时间则被认为是过期(单位是 **秒**)              |
| `s-maxage=<seconds>`  | 设置共享缓存的最大存储周期，会覆盖 `max-age` 和 `expires`，私有缓存会忽略它    |
| `min-fresh=<seconds>` | 客户端希望能在指定的时间内，获取最新的响应                                     |
| `must-revalidate`     | 一旦缓存资源过期，需要向服务器重新发起验证                                     |
| `proxy-revalidate`    | 与 `must-revalidate` 作用相同，但是只用于共享缓存，并被私有缓存忽略            |

#### 协商缓存 {#consult-cache}

- 协商缓存简单定义就是 **和服务器协商确认下缓存是否有效**;
- 如果在 **请求头** 中设置了 `If-Modified-Since` 或 `If-None-Match` 字段，则在发起请求时，会先向服务器去验证是否命中协商缓存，如果命中，则返回 `304` 状态码并在 **响应头** 中带上 `Last-Modified` 或 `ETag` 字段，再通知客户端从缓存中读取资源;

##### `Last-Modified / If-Modified-Since` 组合字段

- 这两个字段都是 UTC 格式的时间字符串，代表的是 **文件修改的最后时间**;
- **前者是响应头的字段，后者是请求头的字段**;
- 客户端第一次发起请求后，服务器在返回响应时，会把资源的最后修改时间放到 `Last-Modified` 字段中;
- 客户端再次发起请求时，会将上一次请求返回的 `Last-Modified` 的值放到请求头中的 `If-Modified-Since` 字段中，再发送到服务器，然后服务器再 **根据文件修改的最后时间和该值进行比较**，如果相等，说明资源没有发生变化，则返回 `304`，加载浏览器缓存;
- **缺点**:
  - 如果服务器中的资源被修改了，但实际内容并无变化(如 某个文件没有修改内容，但进行了保存操作)，这样它修改的时间最后就会和 `If-Modified-Since` 的值匹配不上，导致缓存失效，即使和上一次的响应内容是一致的;

##### `ETag / If-None-Match` 组合字段

- 这两个字段都是一串 hash 值字符串，代表 **每个资源的唯一标识符**，只要资源发生变化，都会导致 `ETag` 也变化;
- **前者是响应头的字段，后者是请求头的字段**;
- `ETag` 是 http 1.1 中新增的字段，用来强化 `Last-Modified`， 解决其缺陷问题，且 **优先级要高于 `Last-Modified`**;
- 客户端二次请求时，会将服务器返回的 `ETag` 的值放到 `If-None-Match` 字段中，服务器再通过该字段和当前资源的 hash 值对比，如果相等，则命中了协商缓存，返回 `304`，加载浏览器缓存;
- `ETag` 也有强弱校验之分，如果 hash 码是以 `W/` 开头的字符串，说明该协商缓存是弱校验，容易生成，但不利于比较;

#### 总结

以上两种 http 缓存策略的流程图如下:

<!--
<Image src={require('./img/http-cache-1.jpg').default} width='90%' height={360} />
-->

<Image src='//aone-time.icu/group1/dino/column-service/http-cache-1.jpg' height={360} width='90%' />

:::tip 参考资料

- 👉 [为什么第二次打开页面快？吃透前端缓存，让页面飞起 - 掘金](https://juejin.cn/post/6993358764481085453)
- 👉 [HTTP 缓存 - 掘金](https://juejin.cn/post/7060876277376352293)
- 👉 [图解 HTTP 缓存 - 极客邦](https://www.infoq.cn/article/aiwqlgtlk2eft5yi7doy)

:::

## HTTPS 知识点

- 由于 http 的通信使用的是 **明文传输**，且不会验证通信方的身份，因此存在着很多安全问题，比如数据被中间人(黑客)拦截或伪造等;
- https 是 **超文本安全传输协议**，相当于是强化版的 http，它是在 **应用层(HTTP)** 和 **传输层(TCP)** 之间增加了一个 **安全层(SSL/TLS 加密协议)**，并且所有的信息都是加密传输的，还配置了身份验证，因此大大提高了网络传输的安全性，如下图;

<!--
<Image src={require('./img/https.png').default} width='70%' height={360} />
 -->

<Image src='//aone-time.icu/group1/dino/column-service/https.png' height={360} width='70%' />

### SSL/TSL 中的加密算法

##### 对称加密算法

- 定义: **客户端和服务器共享一个相同的密钥**;
- 加解密过程:
  - 客户端发送给服务器一个随机数 `client-random` 和 `加密方法`;
  - 服务器返回给客户端另一个随机数 `server-random` 和 `加密方法`;
  - 然后二者通过加密方法将这两个随机数进行混合，生成密钥，完成加密传输;
- **缺点**:
  - 由于首次通信时，都要发送随机数和加密方法，该过程就很容易被拦截解密，从而造成数据的泄漏;

##### 非对称加密算法

- 定义: **客户端和服务器使用公钥和私钥进行加解密**;
- 加解密过程:
  - 客户端发送给服务器一个随机数 `client-random` 和 `加密方法`;
  - 服务器返回给客户端另一个随机数 `server-random`、 `加密方法` 和 `公钥`;
  - 然后客户端用公钥将随机数加密，生成密钥，再传输给服务器，然后服务器使用自己的 `私钥` 进行解密; 这样大大提高了安全性;
- 私钥 只需保存在服务器中即可，并且服务器只需维持一个私钥就能够和多个客户端进行加密通信;
- **缺点**:
  - 在数据加解密中消耗时间可能会较长，降低数据传输的效率;

##### 对称加密 + 非对称加密算法(HTTPS 采用该方式)

- 由于 对称加密 和 非对称加密 都有各自比较明显的优势和缺点，所以 `HTTPS(TSL)` 将这两种算法结合起来，先使用 **对称加密算法 生成密钥**，再使用 **非对称加密算法 对密钥进行加密，进行交换**，交换完成后，再使用 **对称加密方式 进行数据的传输 & 加解密**;
- **缺点**:
  - 由于公钥是公开的，所以针对私钥加密的信息，黑客可以使用公钥进行解密，获取其中的内容;
  - 服务器发送给客户端的 公钥 可能会被黑客截取并篡改;

:::info 离离原上谱

- `SSL/TSL` 的版本:
  - `TSL` 是 `SSL` 的升级版，目前 `SSL` 的版本均已被废弃，主流的版本是 `TSL 1.2` 和 `TSL 1.3`;
- **公钥**、**私钥** 的区别和作用:
  - 公钥是 **公开的密钥**，私钥是 **只有自己知道的密钥**，他们都是成对出现;
  - **公钥** 主要用于敏感信息的加密，保证数据的安全性; **私钥** 主要用于签名，标记信息的发送方身份;
  - 用 **公钥** 加密的数据只有其对应的私钥可以解密; 用 **私钥** 签名只有其对应的公钥可以验签;

:::

### HTTPS 安全数字证书

- 即便 HTTPS 使用了更安全的信息加密传输，但仍然存在一个问题，那就是服务器可能会被黑客冒充，或者公钥被黑客拦截并篡改，而对客户端而言，并不知道自己访问的是什么服务器，从而造成信息泄漏;
- 这时客户端要想 **验证服务器的身份**，就需要服务器引入第三方权威机构(CA)颁发的数字证书，该证书中包含了 **数字签名(验证证书)**、**签发者**、**证书用途**、**使用者公钥**、**使用者的 hash 算法**、**证书到期时间**等信息;
- **数字签名** 的作用:
  - 在颁发证书时，CA 会用自带的 hash 算法对证书的内容进行 hash，得到一个摘要，再用自己的私钥进行加密，得到一个数字签名;
  - 当服务器收到证书时，再次同样的算法生成摘要，然后用 CA 的公钥对数字签名解密，得到 CA 已创建好的摘要，二者一对比，就能知道 **证书是否被人篡改**，最大程度的保证通信的安全;
- 引入证书之后，HTTPS 的信息传输整体过程分为 **证书验证** 和 **数据传输阶段**，如下图:

<!--
<Image src={require('./img/https-1.jpeg').default} width='50%' />
 -->

<Image src='//aone-time.icu/group1/dino/column-service/https-1.jpeg' width='50%' />

- 证书认证又分为 **单向认证** 和 **双向认证**;
  - **单向认证**: 服务器发送证书，客户端验证证书(大多数 https 服务器都是单向认证);
  - **双向认证**: 服务器和客户端分别提供证书给对方，并相互验证对方的证书(比如 网银，银行等场景需要双向认证);

:::tip 参考资料

- 👉 [经得住拷问的 HTTPS 原理解析 - 微信](https://mp.weixin.qq.com/s/atyLhnc2flGwoJpSHBoKTQ)

:::

### http 和 https 的区别

|                      | `HTTP`           | `HTTPS`                                                              |
| -------------------- | ---------------- | -------------------------------------------------------------------- |
| **标准端口**         | 80               | 443                                                                  |
| **信息传输方式**     | 明文传输，不安全 | 由 SSL/TLS + HTTP 协议构建而成，可进行加密传输，身份认证，提高安全性 |
| **基于的网络模型**   | 基于 **应用层**  | 基于 **传输层**                                                      |
| **是否需要证书**     | --               | ✅                                                                   |
| **SEO 搜索引擎优化** | 不利于 SEO       | 对 SEO 友好，搜索引擎会优先搜索 https 网站                           |

:::tip 拓展资料

- 👉 [分享 4 个解决 https 页面加载 http 资源报错的方法 - 微信](https://mp.weixin.qq.com/s/Tpth-pCpDjPFVzJdHsCXUg)

:::

## HTTP 版本变迁

export function Text({ children, defect = false, style = {} }) {
  return (
    <Typography.Text
      type='secondary'
      style={{ fontSize: 13, display: 'block', lineHeight: 1.875, margin: '4px 0', ...style }}
    >
      {defect ? '❗️' : '🔅'} {children}
    </Typography.Text>
  );
}

export function IconClock() {
  // style={{ color: 'rgb(0, 180, 42)' }}
  return <IconClockCircle />;
}

<Timeline labelPosition='relative'>
  <Timeline.Item label='Founded in 1996' dot={<IconClock />}>
    HTTP 1.0
    <Text>任何格式的内容都可以发送，使互联网不仅可以传输文字，还可传输图像，二进制文件等;</Text>
    <Text>除 GET 外，引入了 POST、HEAD 请求方式;</Text>
    <Text>传输通信中增加了信息头(HTTP header)，来描述一些元数据;</Text>
    <Text defect style={{ paddingBottom: 24 }}>
      每个 TCP 连接只能发送一次，发送完成，连接就关闭，导致网络传输性能较差;
    </Text>
  </Timeline.Item>
  <Timeline.Item label='Founded in 1997' dot={<IconClock />}>
    HTTP 1.1(当前主流版号)
    <Text>引入了更多的请求方式 PUT、PATCH、DELETE、OPTIONS、TRACE、PATCH;</Text>
    <Text>
      引入了 长连接/持久连接，即在 TCP 连接默认不关闭，可以被多个请求所复用，请求头会默认设置
      <code>connection: keep-alive</code>;
    </Text>
    <Text>引入了 管道连接 模式，即在同一个 TCP 连接中，可以同时发送多个请求;</Text>
    <Text>
      强化了 缓存管理 机制，新增了<code>Cache-Control</code>、<code>ETag/If-None-Match</code>
      等信息头字段;
    </Text>
    <Text>支持 分块响应，断点续传 传输方式，利于大文件的传输;</Text>
    <Text defect style={{ paddingBottom: 24 }}>
      http 1.1 相比 http 1.0 做了很多提升和优化，但依然会存在 队头阻塞 问题;
    </Text>
  </Timeline.Item>
  <Timeline.Item label='Founded in 2009' dot={<IconClock />}>
    SPDY
    <Text>Google 开发的基于 TCP 的会话层协议;</Text>
    <Text>
      主要通过压缩、多路复用、请求优先级、http 报头压缩等技术来提升网络速度，优化用户的网络使用体验;
    </Text>
    <Text>SPDY 协议并不是一种用于替代 http 的协议，而是对 http 协议的强化;</Text>
    <Text defect style={{ paddingBottom: 24 }}>
      http 2 是主要基于 SPDY 协议的，所以在 http 2 开发完成之后，浏览器就不再支持该协议了;
    </Text>
  </Timeline.Item>
  <Timeline.Item label='Founded in 2015' dot={<IconClock />}>
    HTTP 2(部分主流浏览器已集成)
    <Text>数据传输时，使用 二进制编码 形式，不再是纯文本，缩小了请求的体积;</Text>
    <Text>
      支持 多路复用，即在一个 TCP 连接中，通过 帧 和 流的方式实现了双向数据流，缓解了 队头阻塞
      问题，极大的提高了传输性能;
    </Text>
    <Text>
      使用 <code>HPACK</code> 头部压缩算法对传输的 header 进行编码，减少 header 的体积;
    </Text>
    <Text>允许服务端主动推送数据给客户端;</Text>
    <Text>支持 TLC 加密功能，更安全，且 TLS 版本必须至少为 1.2;</Text>
    <Text defect style={{ paddingBottom: 24 }}>
      还是没有彻底解决 队头阻塞 的问题
    </Text>
  </Timeline.Item>
</Timeline>

:::tip 参考资料

- 👉 [HTTP 各版本特点 & 区别 - 博客园](https://www.cnblogs.com/FdWzy/p/12567822.html)

:::

## 前端安全 📦

<!-- TODO -->

待续...

## 参考资料

- 👉 [助你拿下 HTTP 和 HTTPS，巩固你的 HTTP 知识体系 - 掘金](https://juejin.cn/post/6994629873985650696#heading-0)
- 👉 [HTTP 灵魂之问，巩固你的 HTTP 知识体系 - 掘金](https://juejin.cn/post/6844904100035821575)
